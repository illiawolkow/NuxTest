# NuxTest Real-Time Game Application

This Django application provides user registration, authentication, and a real-time "number game" using WebSockets. It leverages Django Rest Framework for API endpoints, Django Channels for real-time communication, and Celery with Redis for background tasks.

## Tech Stack

- Python 3.10
- Django 4.x + Django Rest Framework
- Django Channels + Channels-Redis
- Celery 5 + Redis broker
- Daphne ASGI server
- Docker & docker-compose for containerisation

## Quick Start (one-liner)

```bash
docker compose up --build
```

The command builds the Docker image, applies database migrations, starts the web server on http://localhost:8000, launches a Celery worker, and spins up Redis.

## Environment variables

The project works out of the box with default settings. For customisation, create a `.env` file (thanks to `django-environ`) or set variables:

| Variable | Default | Purpose |
|----------|---------|---------|
| `DJANGO_SECRET_KEY` | autogenerated | Django secret key |
| `DEBUG` | `True` | Enable Django debug |
| `DATABASE_URL` | `sqlite:///db.sqlite3` | Database DSN |
| `CELERY_BROKER_URL` | `redis://redis:6379/0` | Celery broker |
| `CELERY_RESULT_BACKEND` | `redis://redis:6379/0` | Celery backend |

---

## Running the stack step-by-step

```
# Build image and start containers
$ docker compose build
$ docker compose up -d redis  # start redis first (optional)
$ docker compose run --rm web python manage.py migrate
# run the web server (Daphne) and Celery worker
$ docker compose up web celery
```

---

## API examples

### Register
```bash
curl -X POST http://localhost:8000/auth/register \ 
  -H "Content-Type: application/json" \
  -d '{"username": "alice", "email": "alice@example.com", "password": "secret1234"}'
```

### Login
```bash
curl -X POST http://localhost:8000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "alice@example.com", "password": "secret1234"}' \
  -c cookies.txt            # store session
```

### Play
```bash
curl -X POST http://localhost:8000/api/game/play \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{"number": 842}'
```

WS result will also arrive on WebSocket:
```js
const socket = new WebSocket("ws://localhost:8000/ws/game/");
socket.onmessage = (e) => console.log(JSON.parse(e.data));
```

### History
```bash
curl -X GET http://localhost:8000/api/game/history -b cookies.txt
```

---

## Running tests

```bash
docker compose run --rm web python manage.py test
```

---

## Scalability & Production considerations

See [docs/scaling.md](docs/scaling.md) for details on horizontal scaling, task queues, caching, securing WebSockets and more. 

База-даних ще не містить таблиці `game_gameresult`, бо для застосунку `game` не було створено й застосовано міграції після додавання моделі.

Як швидко виправити:

1. У контейнері web (або на локальній машині) створіть міграції й застосуйте їх:

```bash
# якщо вже запущені контейнери
docker compose exec web python manage.py makemigrations game
docker compose exec web python manage.py migrate
```

або, якщо контейнери не запущені:

```bash
docker compose run --rm web python manage.py makemigrations game
docker compose run --rm web python manage.py migrate
```

2. Перезапустіть сервер (`docker compose up web`), після чого POST `/api/game/` працюватиме без помилки.

Підказка на майбутнє: коли додаєте нові моделі чи поля, потрібно:

• `makemigrations` – згенерувати файли міграцій  
• `migrate` – застосувати їх до бази даних

Якщо хочете робити це автоматично при кожному старті контейнера, можна змінити команду `web` у `docker-compose.yml`, наприклад:

```yaml
<code_block_to_apply_changes_from>
command: >
  sh -c "python manage.py makemigrations --no-input &&
         python manage.py migrate --no-input &&
         daphne -b 0.0.0.0 -p 8000 NuxTest.asgi:application"
```

Тоді міграції будуть створюватися/застосовуватися автоматично при кожному запуску. 